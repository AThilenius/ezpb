import protobuf from 'protobufjs';
import { bootstrapJson, wlabs } from '../../gen/proto_gen_bootstrap';
import { toCamelCase } from '../../utils/string';
import { bytesToBase64 } from '../../utils/base64';
import { Namespace, treeifyMeta } from '../compiler/treeify_meta';
import { compileFromProtoDefinitions } from '../compiler/proto_ast_compiler';
import { ProtoDefinitions } from '../compiler/proto_loader';
import { GeneratedAPIVersion } from '../../proto_gen_api';

export async function generateTypescript(
  protoPaths: string[],
  runtimeModule: string,
  bootstrap: boolean,
  anyType: boolean
): Promise<string> {
  // Prepare common imports
  protobuf.common(
    'descriptor',
    // eslint-disable-next-line @typescript-eslint/no-var-requires
    require('protobufjs/google/protobuf/descriptor.json')
  );

  // Load the definitions from disk.
  const protoDefinitions = await ProtoDefinitions.fromProtoPaths(protoPaths);

  // Compile the loaded protobufjs Root object into an AST.
  const meta = compileFromProtoDefinitions(protoDefinitions);

  // Convert the Meta object into a namespace tree for easier code-gen.
  const tree = treeifyMeta(meta);

  let code = `
    /**
     * This file is generated by the ezpb CLI. Do not manually edit.
     * @internal
     */
    /* eslint-disable */
  `;

  if (!bootstrap) {
    if (anyType) {
      code += `
        import * as __ProtoGenAPI from '../proto_gen_api';
      `;
    } else {
      code += `
        import {
          ProtoGenAPI as __ProtoGenAPI,
        } from '${runtimeModule}';
      `;
    }

    code += `
    // Type error here? It means you need to re-generate this file with the same
    // version of the ezpb client you're using.
    const ApiVersionAssertion: __ProtoGenAPI.ProtoGenAPIVersion = ${GeneratedAPIVersion};
    `;
  }

  // Generate namespace code recursively.
  code += generateNamespace(tree, bootstrap);

  if (bootstrap) {
    // TODO: Make this resilient to duplicates
    const root = new protobuf.Root();
    const loadedRoots = await Promise.all(
      protoPaths.map((path) => protobuf.load(path))
    );

    for (const loadedRoot of loadedRoots) {
      root.add(loadedRoot);
    }

    code += `
      // The --bootstrap flag was specified, so we register the reflection
      // object as a JSON object instead of the normal proto meta definition.
      export const bootstrapJson = ${JSON.stringify(root.toJSON())};
    `;
  } else {
    const metaProtoRoot = protobuf.Root.fromJSON(bootstrapJson);
    const metaProtoType = metaProtoRoot.lookupType('wlabs.ezpb.meta.Meta');
    const binary = metaProtoType.encode(meta).finish();
    const base64 = bytesToBase64(binary);

    code += `
      // This registers the reflection object for runtime use. It's a binary
      // (base64 encoded) \`protobuf wlabs.ezpb.meta.Meta\` message.
      __ProtoGenAPI.addMetaDefinitionBase64('${base64}');
    `;
  }

  return code;
}

function generateNamespace(namespace: Namespace, bootstrap: boolean): string {
  const lines: string[] = [];

  // Generate enums
  for (const pEnum of namespace.meta.enums ?? []) {
    lines.push(``);
    lines.push(`export enum ${pEnum.name!.name} {`);
    for (const field of pEnum.fields ?? []) {
      lines.push(`${field.name!} = ${field.value},`);
    }
    lines.push('}');
    lines.push(``);
  }

  // Generate types
  const generateField = (
    field: wlabs.ezpb.meta.Type.Field<number | Long.Long>,
    withDefaultValues: boolean
  ) => {
    const TClassification = wlabs.ezpb.meta.Type.Field.Classification;

    // True for all built in protobuf types, including string and bytes.
    const isBuiltinType = Object.prototype.hasOwnProperty.call(
      protobufBuiltinToTsType,
      field.typeFullName!
    );

    let type: string;

    if (isBuiltinType) {
      // A builtin is the primitive proto type converted to the TS type. But, if
      // withDefaultValue is set, then we replace TNum with Long.
      type = protobufBuiltinToTsType[field.typeFullName!];
      if (withDefaultValues && type === 'TNum') {
        type = 'Long';
      }
    } else if (withDefaultValues) {
      // When using withDefaultValues, we need to switch all embedded messages
      // types to their respective *_WithDefaultVales variant. It is not however
      // templated for number type as it's always Long.
      if (field.classification === TClassification.EmbeddedMessage) {
        type = `${field.typeFullName}_WithDefaultValues`;
      } else {
        type = `${field.typeFullName}`;
      }
    } else {
      // With the standard types, we need to pass on the TNum template type if
      // it's a message field.
      if (field.classification === TClassification.EmbeddedMessage) {
        type = `${field.typeFullName}<TNum>`;
      } else {
        type = `${field.typeFullName}`;
      }
    }

    // Fields are optional when either withDefaultValues isn't set, or if the
    // field is a oneof, or is an embedded message that isn't repeated. Those
    // are always optional.
    const optional =
      !withDefaultValues ||
      field.partOf ||
      (field.classification === TClassification.EmbeddedMessage &&
        !field.isRepeated);

    lines.push(
      `${field.name!}${optional ? '?' : ''}: ${type}${
        field.isRepeated ? '[]' : ''
      };`
    );
  };

  for (const type of namespace.meta.types ?? []) {
    // The default message type has all optional fields except enums.
    lines.push(``);
    lines.push(`export interface ${type.name!.name}<TNum = number | Long> {`);
    for (const field of type.fields || []) {
      generateField(field, false);
    }
    lines.push('}');
    lines.push('');

    lines.push(``);
    lines.push(`export interface ${type.name!.name}_WithDefaultValues {`);
    for (const field of type.fields || []) {
      generateField(field, true);
    }
    lines.push('}');
    lines.push('');

    if (bootstrap) {
      continue;
    }

    // Generate the verify, encode and decode functions/methods.
    lines.push(`export namespace ${type.name!.name} {
      export const fullName = '${getFullName(type.name!)}';

      export function verify(obj: ${type.name!.name}): string | null {
        return __ProtoGenAPI.injected.verify(fullName, obj);
      }

      export function encode(
        obj: ${type.name!.name},
        delimitated = false,
      ): Uint8Array {
        return __ProtoGenAPI.injected.encode(fullName, obj, delimitated);
      }

      export function decode(
        data: Uint8Array,
        delimitated = false,
      ): ${type.name!.name}_WithDefaultValues {
        return __ProtoGenAPI.injected.decode(fullName, data, delimitated);
      }
    }
    `);
  }

  // Generate services
  for (const service of namespace.meta.services ?? []) {
    // The *ServerClient and *ServiceHandler types.
    lines.push(``);
    lines.push(`export interface ${service.name!.name!}Client {`);

    for (const method of service.methods ?? []) {
      const reqTypeStr = method.isReqStreamed
        ? `__ProtoGenAPI.ChannelReceiver<${method.reqFullTypeName}>`
        : `${method.reqFullTypeName}`;
      const resTypeStr = method.isResStreamed
        ? `__ProtoGenAPI.ChannelReceiver<${method.resFullTypeName}_WithDefaultValues>`
        : `Promise<${method.resFullTypeName}_WithDefaultValues>`;
      lines.push(
        `${toCamelCase(method.name!)}: (req: ${reqTypeStr}) => ${resTypeStr};`
      );
    }

    lines.push(`}`);
    lines.push(``);

    lines.push(`export interface ${service.name!.name!}Handler {`);

    for (const method of service.methods ?? []) {
      const reqTypeStr = method.isReqStreamed
        ? `__ProtoGenAPI.ChannelReceiver<${method.reqFullTypeName}_WithDefaultValues>`
        : `${method.reqFullTypeName}_WithDefaultValues`;
      const resTypeStr = method.isResStreamed
        ? `__ProtoGenAPI.ChannelReceiver<${method.resFullTypeName}>
        | Promise<__ProtoGenAPI.ChannelReceiver<${method.resFullTypeName}>>
        | AsyncGenerator<${method.resFullTypeName}>`
        : `Promise<${method.resFullTypeName}>
        | ${method.resFullTypeName}`;
      lines.push(
        `${toCamelCase(
          method.name!
        )}: (req: ${reqTypeStr}, ctx: __ProtoGenAPI.CallContext) => ${resTypeStr};`
      );
    }

    lines.push(`}`);
    lines.push(``);

    // Generate the static Service class, used for registering handlers and
    // creating clients.
    lines.push(`
    export namespace ${service.name!.name!} {
      export const fullName = '${getFullName(service.name!)}';

      export function registerHandler(
        scope: __ProtoGenAPI.ServiceScope,
        handler: Partial<${service.name!.name!}Handler>,
      ): () => void {
        return __ProtoGenAPI.injected.registerHandler(fullName, scope, handler);
      }

      export function createClient(
        Node: __ProtoGenAPI.Node,
      ): ${service.name!.name!}Client {
        return __ProtoGenAPI.injected.createClient(fullName, Node);
      }
    }
    `);
  }

  // Finally recurse down into children namespaces
  for (const child of namespace.children) {
    lines.push(``);
    if (child.name) {
      lines.push(`export namespace ${child.name} {`);
      lines.push(generateNamespace(child, bootstrap));
      lines.push(`}`);
    } else {
      lines.push(generateNamespace(child, bootstrap));
    }
    lines.push(``);
  }

  return lines.join('\n');
}

function getFullName(name: wlabs.ezpb.meta.Name): string {
  if (name.namespace) {
    return name.namespace! + '.' + name.name;
  } else {
    return name.name!;
  }
}

const protobufBuiltinToTsType: { [key: string]: string } = {
  double: 'number',
  float: 'number',
  int32: 'number',
  int64: 'TNum',
  uint32: 'number',
  uint64: 'TNum',
  sint32: 'number',
  sint64: 'TNum',
  fixed32: 'number',
  fixed64: 'TNum',
  sfixed32: 'number',
  sfixed64: 'TNum',
  bool: 'boolean',
  string: 'string',
  bytes: 'Uint8Array',
};
